<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Distributed Security Experiment - SCULI Demo</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vis-network@latest/dist/vis-network.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #2d3748 0%, #4a5568 100%);
            color: #333;
        }
        .container {
            max-width: 1800px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .header p {
            margin: 10px 0 0 0;
            font-size: 1.2em;
            opacity: 0.9;
        }
        .dashboard {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        .card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .card h3 {
            margin-top: 0;
            color: #4a5568;
            border-bottom: 2px solid #e2e8f0;
            padding-bottom: 10px;
        }
        .network-container {
            height: 500px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
        }
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }
        .metric-item {
            background: #f7fafc;
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid #4299e1;
        }
        .metric-item.suspicious {
            border-left-color: #ed8936;
        }
        .metric-item.compromised {
            border-left-color: #e53e3e;
        }
        .metric-item.under-attack {
            border-left-color: #9f7aea;
        }
        .metric-item.isolated {
            border-left-color: #718096;
        }
        .metric-item.cross-domain-threat {
            border-left-color: #d53f8c;
        }
        .metric-score {
            font-size: 1.5em;
            font-weight: bold;
            color: #2d3748;
        }
        .node-id {
            font-weight: bold;
            color: #4a5568;
        }
        .node-info {
            font-size: 0.9em;
            color: #718096;
        }
        .domain-tag {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.8em;
            font-weight: bold;
            margin-right: 5px;
        }
        .domain-smartcity { background: #bee3f8; color: #2b6cb0; }
        .domain-industrialiot { background: #fbb6ce; color: #97266d; }
        .domain-transportation { background: #c6f6d5; color: #22543d; }
        .domain-energygrid { background: #fef5e7; color: #744210; }
        .domain-healthcare { background: #e9d8fd; color: #553c9a; }
        .domain-finance { background: #fed7d7; color: #742a2a; }
        .status {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
            text-transform: uppercase;
        }
        .status.secure {
            background: #c6f6d5;
            color: #22543d;
        }
        .status.suspicious {
            background: #fef5e7;
            color: #744210;
        }
        .status.compromised {
            background: #fed7d7;
            color: #742a2a;
        }
        .status.under-attack {
            background: #e9d8fd;
            color: #553c9a;
        }
        .status.isolated {
            background: #e2e8f0;
            color: #4a5568;
        }
        .status.cross-domain-threat {
            background: #fbb6ce;
            color: #97266d;
        }
        .chart-container {
            position: relative;
            height: 300px;
        }
        .incidents-panel {
            max-height: 400px;
            overflow-y: auto;
        }
        .incident-item {
            background: #f7fafc;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            border-left: 4px solid #e53e3e;
        }
        .incident-item.cross-domain {
            border-left-color: #d53f8c;
        }
        .incident-id {
            font-weight: bold;
            color: #2d3748;
        }
        .incident-time {
            font-size: 0.9em;
            color: #718096;
        }
        .incident-actions {
            margin-top: 10px;
        }
        .action-tag {
            display: inline-block;
            background: #4299e1;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.8em;
            margin-right: 5px;
        }
        .attack-indicators {
            margin-top: 10px;
        }
        .indicator {
            background: #fed7d7;
            color: #742a2a;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.8em;
            margin-right: 5px;
            margin-bottom: 5px;
            display: inline-block;
        }
        .indicator.cross-domain {
            background: #fbb6ce;
            color: #97266d;
        }
        .system-metrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .system-metric {
            text-align: center;
            padding: 15px;
            background: #f7fafc;
            border-radius: 8px;
        }
        .system-metric-value {
            font-size: 2em;
            font-weight: bold;
            color: #4299e1;
        }
        .system-metric-label {
            color: #718096;
            font-size: 0.9em;
        }
        .supply-chain-panel {
            background: #f7fafc;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }
        .supply-chain-item {
            background: white;
            border-radius: 5px;
            padding: 10px;
            margin-bottom: 10px;
            border-left: 3px solid #4299e1;
        }
        .supply-chain-item.vulnerable {
            border-left-color: #e53e3e;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåê Distributed Security Experiment</h1>
            <p>SCULI: Securing Compromised Cyber-Physical Systems</p>
            <p>Converged Digital Infrastructure Security Monitoring</p>
        </div>

        <div class="dashboard">
            <div class="card">
                <h3>üåê Cross-Domain System Topology</h3>
                <div class="network-container" id="network"></div>
            </div>

            <div class="card">
                <h3>üö® Active Incidents & Cross-Domain Threats</h3>
                <div class="incidents-panel" id="incidentsPanel">
                    <!-- Incidents will be populated here -->
                </div>
            </div>
        </div>

        <div class="card">
            <h3>üìä Security Metrics by Domain & Hardware Type</h3>
            <div class="metrics-grid" id="metricsGrid">
                <!-- Security metrics will be populated here -->
            </div>
        </div>

        <div class="card">
            <h3>üìà Cross-Domain Security Trends</h3>
            <div class="chart-container">
                <canvas id="securityChart"></canvas>
            </div>
        </div>

        <div class="card">
            <h3>üîó Supply Chain Components</h3>
            <div class="supply-chain-panel" id="supplyChainPanel">
                <!-- Supply chain components will be populated here -->
            </div>
        </div>

        <div class="card">
            <h3>üìä System Overview</h3>
            <div class="system-metrics">
                <div class="system-metric">
                    <div class="system-metric-value" id="totalNodes">0</div>
                    <div class="system-metric-label">Total Nodes</div>
                </div>
                <div class="system-metric">
                    <div class="system-metric-value" id="secureNodes">0</div>
                    <div class="system-metric-label">Secure</div>
                </div>
                <div class="system-metric">
                    <div class="system-metric-value" id="crossDomainThreats">0</div>
                    <div class="system-metric-label">Cross-Domain Threats</div>
                </div>
                <div class="system-metric">
                    <div class="system-metric-value" id="legacyNodes">0</div>
                    <div class="system-metric-label">Legacy Systems</div>
                </div>
                <div class="system-metric">
                    <div class="system-metric-value" id="activeIncidents">0</div>
                    <div class="system-metric-label">Active Incidents</div>
                </div>
                <div class="system-metric">
                    <div class="system-metric-value" id="avgSecurity">0%</div>
                    <div class="system-metric-label">Avg Security</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let securityChart;
        let network;
        let securityData = [];
        let incidentData = [];
        let topologyData = null;

        // Initialize charts and network
        function initVisualizations() {
            // Security trends chart
            const ctx = document.getElementById('securityChart').getContext('2d');
            securityChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Average Security Score',
                        data: [],
                        borderColor: '#4299e1',
                        backgroundColor: 'rgba(66, 153, 225, 0.1)',
                        tension: 0.4
                    }, {
                        label: 'Average Threat Level',
                        data: [],
                        borderColor: '#e53e3e',
                        backgroundColor: 'rgba(229, 62, 62, 0.1)',
                        tension: 0.4
                    }, {
                        label: 'Cross-Domain Threats',
                        data: [],
                        borderColor: '#d53f8c',
                        backgroundColor: 'rgba(213, 63, 140, 0.1)',
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 1.0
                        }
                    }
                }
            });

            // Network visualization
            const container = document.getElementById('network');
            network = new vis.Network(container, { nodes: [], edges: [] }, {
                nodes: {
                    shape: 'dot',
                    size: 25,
                    font: { size: 12, color: '#000' },
                    borderWidth: 3
                },
                edges: {
                    width: 3,
                    color: { color: '#848484' }
                },
                physics: {
                    enabled: true,
                    stabilization: { iterations: 100 }
                }
            });
        }

        // Update security metrics grid
        function updateMetricsGrid(metrics) {
            const grid = document.getElementById('metricsGrid');
            grid.innerHTML = '';

            metrics.forEach(metric => {
                const item = document.createElement('div');
                item.className = `metric-item ${metric.status.toLowerCase().replace('_', '-')}`;
                
                const statusClass = metric.status.toLowerCase().replace('_', '-');
                const statusText = metric.status.charAt(0).toUpperCase() + metric.status.slice(1).replace('_', ' ');
                const domainClass = `domain-${metric.domain.toLowerCase().replace('_', '')}`;
                const domainText = metric.domain.charAt(0).toUpperCase() + metric.domain.slice(1).replace('_', ' ');
                
                let indicatorsHtml = '';
                if (metric.attack_indicators && metric.attack_indicators.length > 0) {
                    indicatorsHtml = '<div class="attack-indicators">';
                    metric.attack_indicators.forEach(indicator => {
                        const indicatorClass = indicator.indicator_type.includes('cross_domain') ? 'cross-domain' : '';
                        indicatorsHtml += `<span class="indicator ${indicatorClass}">${indicator.indicator_type}</span>`;
                    });
                    indicatorsHtml += '</div>';
                }
                
                item.innerHTML = `
                    <div class="node-id">${metric.node_id}</div>
                    <div class="node-info">
                        <span class="domain-tag ${domainClass}">${domainText}</span>
                        ${metric.hardware_type}
                    </div>
                    <div class="node-info">Security: ${(metric.overall_security * 100).toFixed(1)}%</div>
                    <div class="metric-score">${(metric.overall_security * 100).toFixed(1)}%</div>
                    <div class="status ${statusClass}">${statusText}</div>
                    ${indicatorsHtml}
                `;
                
                grid.appendChild(item);
            });
        }

        // Update incidents panel
        function updateIncidentsPanel(incidents) {
            const panel = document.getElementById('incidentsPanel');
            panel.innerHTML = '';

            if (incidents.length === 0) {
                panel.innerHTML = '<p style="text-align: center; color: #718096;">No active incidents</p>';
                return;
            }

            incidents.forEach(incident => {
                const item = document.createElement('div');
                item.className = `incident-item ${incident.cross_domain_coordination ? 'cross-domain' : ''}`;
                
                const responseType = incident.response_type.charAt(0).toUpperCase() + incident.response_type.slice(1);
                const status = incident.status.charAt(0).toUpperCase() + incident.status.slice(1);
                
                let actionsHtml = '';
                if (incident.actions_taken && incident.actions_taken.length > 0) {
                    actionsHtml = '<div class="incident-actions">';
                    incident.actions_taken.forEach(action => {
                        actionsHtml += `<span class="action-tag">${action}</span>`;
                    });
                    actionsHtml += '</div>';
                }
                
                let domainsHtml = '';
                if (incident.affected_domains && incident.affected_domains.length > 0) {
                    domainsHtml = `<div class="node-info">Affected Domains: ${incident.affected_domains.join(', ')}</div>`;
                }
                
                item.innerHTML = `
                    <div class="incident-id">${incident.incident_id.substring(0, 8)}...</div>
                    <div class="node-info">Node: ${incident.node_id}</div>
                    <div class="node-info">Type: ${responseType}</div>
                    ${domainsHtml}
                    <div class="incident-time">${new Date(incident.timestamp).toLocaleTimeString()}</div>
                    <div class="status">${status}</div>
                    ${actionsHtml}
                `;
                
                panel.appendChild(item);
            });
        }

        // Update supply chain panel
        function updateSupplyChainPanel(topology) {
            const panel = document.getElementById('supplyChainPanel');
            panel.innerHTML = '';

            if (!topology || !topology.supply_chain_components) {
                panel.innerHTML = '<p style="text-align: center; color: #718096;">No supply chain data</p>';
                return;
            }

            topology.supply_chain_components.forEach(component => {
                const item = document.createElement('div');
                item.className = `supply-chain-item ${component.vulnerabilities.length > 0 ? 'vulnerable' : ''}`;
                
                let vulnerabilitiesHtml = '';
                if (component.vulnerabilities.length > 0) {
                    vulnerabilitiesHtml = '<div style="margin-top: 5px;">';
                    component.vulnerabilities.forEach(vuln => {
                        vulnerabilitiesHtml += `<span style="background: #fed7d7; color: #742a2a; padding: 2px 4px; border-radius: 2px; font-size: 0.8em; margin-right: 3px;">${vuln}</span>`;
                    });
                    vulnerabilitiesHtml += '</div>';
                }
                
                item.innerHTML = `
                    <div style="font-weight: bold;">${component.component_id}</div>
                    <div style="font-size: 0.9em; color: #718096;">Vendor: ${component.vendor} | Version: ${component.version}</div>
                    <div style="font-size: 0.9em; color: #4299e1;">Trust Level: ${(component.trust_level * 100).toFixed(1)}%</div>
                    ${vulnerabilitiesHtml}
                `;
                
                panel.appendChild(item);
            });
        }

        // Update network visualization
        function updateNetwork(topology) {
            if (!topology) return;

            const nodes = new vis.DataSet(
                topology.nodes.map(node => ({
                    id: node.node_id,
                    label: node.node_id,
                    color: getNodeColor(node.trust_level, node.domain),
                    title: `${node.node_id}\nDomain: ${node.domain}\nTrust: ${(node.trust_level * 100).toFixed(1)}%`
                }))
            );

            const edges = new vis.DataSet(
                topology.cross_domain_connections.map(conn => ({
                    from: conn.from_node,
                    to: conn.to_node,
                    color: getEdgeColor(conn.security_level),
                    title: `Security: ${(conn.security_level * 100).toFixed(1)}%\nTrust: ${(conn.trust_relationship * 100).toFixed(1)}%`
                }))
            );

            network.setData({ nodes, edges });
        }

        // Get node color based on trust level and domain
        function getNodeColor(trustLevel, domain) {
            if (trustLevel >= 0.8) return '#48bb78';
            if (trustLevel >= 0.6) return '#ed8936';
            if (trustLevel >= 0.4) return '#e53e3e';
            if (trustLevel >= 0.2) return '#9f7aea';
            return '#718096';
        }

        // Get edge color based on security level
        function getEdgeColor(securityLevel) {
            if (securityLevel >= 0.8) return '#48bb78';
            if (securityLevel >= 0.6) return '#ed8936';
            return '#e53e3e';
        }

        // Update system metrics
        function updateSystemMetrics(metrics, incidents) {
            const total = metrics.length;
            const secure = metrics.filter(m => m.status === 'Secure').length;
            const crossDomainThreats = metrics.filter(m => m.status === 'CrossDomainThreat').length;
            const legacyNodes = metrics.filter(m => m.hardware_type === 'LegacyX86').length;
            const activeIncidents = incidents.length;
            const avgSecurity = metrics.reduce((sum, m) => sum + m.overall_security, 0) / total;

            document.getElementById('totalNodes').textContent = total;
            document.getElementById('secureNodes').textContent = secure;
            document.getElementById('crossDomainThreats').textContent = crossDomainThreats;
            document.getElementById('legacyNodes').textContent = legacyNodes;
            document.getElementById('activeIncidents').textContent = activeIncidents;
            document.getElementById('avgSecurity').textContent = `${(avgSecurity * 100).toFixed(1)}%`;
        }

        // Update charts
        function updateCharts(metrics) {
            const now = new Date().toLocaleTimeString();
            const avgSecurity = metrics.reduce((sum, m) => sum + m.overall_security, 0) / metrics.length;
            const avgThreat = metrics.reduce((sum, m) => sum + m.threat_level, 0) / metrics.length;
            const crossDomainThreats = metrics.filter(m => m.status === 'CrossDomainThreat').length / metrics.length;
            
            securityChart.data.labels.push(now);
            securityChart.data.datasets[0].data.push(avgSecurity);
            securityChart.data.datasets[1].data.push(avgThreat);
            securityChart.data.datasets[2].data.push(crossDomainThreats);
            
            if (securityChart.data.labels.length > 20) {
                securityChart.data.labels.shift();
                securityChart.data.datasets[0].data.shift();
                securityChart.data.datasets[1].data.shift();
                securityChart.data.datasets[2].data.shift();
            }
            
            securityChart.update('none');
        }

        // Fetch data
        async function fetchData() {
            try {
                const [securityResponse, incidentsResponse, topologyResponse] = await Promise.all([
                    fetch('/api/security'),
                    fetch('/api/incidents'),
                    fetch('/api/topology')
                ]);

                const securityMetrics = await securityResponse.json();
                const incidents = await incidentsResponse.json();
                const topology = await topologyResponse.json();

                securityData = securityMetrics;
                incidentData = incidents;
                topologyData = topology;

                updateMetricsGrid(securityMetrics);
                updateIncidentsPanel(incidents);
                updateSupplyChainPanel(topology);
                updateNetwork(topology);
                updateSystemMetrics(securityMetrics, incidents);
                updateCharts(securityMetrics);

            } catch (error) {
                console.error('Error fetching data:', error);
            }
        }

        // Initialize and start polling
        initVisualizations();
        fetchData();
        setInterval(fetchData, 4000);
    </script>
</body>
</html>
